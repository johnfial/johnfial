


# CCI_ch2_01_remove_duplicates.py
# Remove Duplicates:

# Write code to remove duplicates from an unsorted linked list.

# Hints: 9, 40
# FOLLOW UP: How would you solve this problem if a temporary buffer is not allowed?






# CCI_ch2_02
# Return Kth to Last:
# Implement an algorithm to find the kth to last element of a singly linked list:

# Hints: 8, 25, 41, 67, 126






# CCI_ch2_03_delete_middle_node.py
# Delete Middle Node:
# Implement an algorithm to delete a node in the middle (i.e. NOT the first or last node,
# not necessarily the exact middle) of a singly linked list, given only access to that node.

# EXAMPLE:
# input: the node c from the linked list a -> b -> c -> d -> e -> f
# output : nothing returned, but the new list is a -> b -> d -> e -> f

# Hints: 72




# CCI_ch2_04_partition.py
# Partition:
# Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x. 
# (IMPORTANT: The partition element x can appear anywhere in the "right partition", it does not need to appear between the left and right partitions.
# The additional spacing in the example below indicates the partition. 
# Yes, the output below is one of many valid outputs!)

# EXAMPLE:

# input 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1        [partition = 5]
# output: 3 -> 1 -> 2    ->         10 -> 5 -> 5 -> 8

# Hints: 3, 24





# CCI_ch2_05_sum_lists.py









# CCI_ch2_06_palindrome.py
# Palindrome:

# Implement a function to check if a linked list is a palindrome. (same forward/backwards)

# Hints: 5, 13, 29, 61, 101














# CCI_ch2_07_intersection.py
# CCI_ch2_08_loop_detection.py
